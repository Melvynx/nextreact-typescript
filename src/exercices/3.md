# Custom hooks

On se rappelle une rÃ¨gle sacrÃ©e concernant React :

|-------------|
| Code mÃ©tier |
|-------------|
Â Â Â Â Â Â |
Â Â Â Â Â Â |
|-------------|
| Hooks |
|-------------|
Â Â Â Â Â Â |
Â Â Â Â Â Â |
|-------------|
| Components |
|-------------|

On n'aime pas en React avoir trop de code mÃ©tier ou des hooks dans nos composants. On cherche toujours Ã  les isoler dans des fonctions ou des hooks.

C'est pour Ã§a qu'un refactor de notre code s'impose.

> PS : j'exagÃ¨re volontairement ce genre de refactor, mÃªme si c'est pas toujours pertinent pour tâ€™habituer Ã  toujours vouloir bien sÃ©parer les choses. Ce n'est pas une loi, mais une bonne pratique.

â„¹ï¸ Ã€ partir de cet exercice, les pseudos des users sont prÃ©dÃ©finis pour simplifier le test
de l'exercice.

## Part 1 : Custom hooks pour UserNames

Notre composant `UserNamesForm` c'est le formulaire qui nous permet de dÃ©finir nos userNames.

Le problÃ¨me c'est que la il y a deux hooks, des fonctions etc... et peut-Ãªtre qu'un jour, on va refactor dans des contexts ou mÃªme quand l'utilisera autre part.

Dans un but d'exercice, refactor ce composant avec un custom hooks `useUserNamesForm`.

Ce que je veux que tu fasses est de dÃ©finir le type de ce custom hooks :

- les paramÃ¨tres qu'il prend ;
- les valeurs qu'il retourne ;

Voici Ã  quoi il devrait ressembler :

```tsx
const useUserNamesForm = (params: Params): ReturnType => {
  // ...
};
```

- ğŸ’Œ Tu apprends Ã  refactor ton code avec des custom hooks en utilisant des types.

## Part 2 : Custom hooks pour notre jeu

Le composant `Game` commence Ã  lui aussi avoir beaucoup de logique... et c'est loin d'Ãªtre terminer, car il va falloir gÃ©rer les tours, les scores, les victoires etc...

Refactor ce composant avec un custom hooks `useGame`.

Comme dans l'exercice prÃ©cÃ©dent, crÃ©er le type qu'il prend en paramÃ¨tre ainsi que le type qu'il retourne.

Aussi dÃ©finir le type de retours.

- ğŸ’Œ Tu apprends Ã  refactor ton code avec des custom hooks avec des types.
